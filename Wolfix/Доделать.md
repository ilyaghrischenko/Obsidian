
В данном документе представлен анализ текущего состояния проекта `Wolfix.Server` (Модульный монолит на .NET 9). Выявленные проблемы разделены по категориям критичности и влияния на систему. Для каждой проблемы предложены решения или направления для рефакторинга.

- [ ] чтобы у корзины можно было менять количество на каждом товаре
- [ ] 

---

## 1. Межмодульное взаимодействие и Связность (High Criticality)

### Проблема: Синхронная коммуникация через EventBus (Псевдо-RPC)
В коде используется метод `PublishWithSingleResultAsync`. Модули отправляют событие и *ждут* ответа от другого модуля (например, `CheckUserExistsAndHasRoleAsync` или получение ID профиля).
* **Риск:** Это создает жесткую (temporal coupling) связность. Если один модуль ("Identity") работает медленно или недоступен, второй модуль ("Catalog") падает или зависает. Теряется смысл событийной модели.
* **Диагноз:** Использование шины событий как механизма удаленного вызова процедур (RPC).

### Решение: Разделение на Queries и Commands
Необходимо разделить способы общения модулей в зависимости от цели.

**Направление реализации:**
1.  **Для получения данных (Queries):** Внедрите **Public Interface** (Публичный интерфейс) модуля.
    * Создайте интерфейс `IIdentityModuleApi` в `Identity.Application` (или в Shared слое, если позволяет архитектура).
    * Реализуйте его в модуле Identity.
    * Внедрите этот интерфейс напрямую в `CatalogService`.
    * *Почему это лучше:* Это типизированный, синхронный вызов внутри одного процесса. Это быстрее и надежнее, чем гонять события через шину для простого чтения данных.
2.  **Для действий (Commands/Side Effects):** Оставьте `EventBus` (или `MassTransit`) только для ситуаций "Fire-and-Forget" (Выстрелил и забыл).
    * *Пример:* "Заказ создан" -> Отправить событие. Модуль уведомлений слушает и шлет email. Если модуль уведомлений упал, заказ все равно создан.

---

## 2. Консистентность данных и Надежность (High Criticality)

### Проблема: Отсутствие атомарности (Dual Write Problem)
В сервисах (например, `ProductService`) происходит следующее:
1.  `await _repository.SaveChangesAsync(ct);` (Запись в БД)
2.  `await _eventBus.Publish...` (Отправка события)

* **Риск:** Если приложение упадет (сбой питания, OOM, перезагрузка пода) *после* шага 1, но *перед* шагом 2, данные в БД сохранятся, но событие не уйдет. Система придет в несогласованное состояние (товар есть, но поиск не обновился, или письмо не ушло).

### Решение: Паттерн Transactional Outbox
Необходимо гарантировать, что событие будет отправлено, если транзакция БД прошла успешно.

**Направление реализации:**
1.  **Использование MassTransit (Open Source):** Эта библиотека "из коробки" поддерживает Transactional Outbox с Entity Framework Core.
    * Она создает таблицу `OutboxMessage` в вашей БД.
    * Событие сохраняется в эту таблицу в той же транзакции, что и создание продукта.
    * Фоновый воркер (входит в библиотеку) читает таблицу и отправляет сообщения в брокер (RabbitMQ или in-memory).
2.  **Ручная реализация (если не хочется внешних либ):**
    * Создать сущность `OutboxMessage` в `DbContext`.
    * При публикации события не слать его сразу, а добавлять в `DbSet<OutboxMessage>`.
    * Написать `BackgroundService`, который в цикле читает эту таблицу и отправляет сообщения.

---

## 3. Слой доступа к данным (Medium Criticality)

### Проблема: Generic Repository (`BaseRepository`) поверх EF Core
Используется самописная обертка `BaseRepository<T>`.
* **Риск:** `DbContext` и `DbSet` в EF Core уже реализуют паттерны Unit of Work и Repository. Оборачивание их в еще один слой скрывает мощные возможности EF (проекции через `.Select()`, `SplitQuery`, оптимизации SQL). Приходится писать "костыли" вроде передачи строк `includeProperties` для жадной загрузки.

### Решение: Специфичные репозитории или Specification Pattern

**Направление реализации:**
1.  **Специфичные репозитории:**
    * В `IProductRepository` и его реализации используйте `DbContext` напрямую.
    * Это позволит писать сложные LINQ-запросы с `Join`, `Group By` и проекциями в DTO прямо на уровне базы данных.
2.  **Отказ от BaseRepository:** Удалите методы `GetAll`, `GetById` из базового класса, если они требуют передачи строковых параметров для Include. Оставьте только базовые `Add` и `Delete`.

---

## 4. Организация бизнес-логики (Medium Criticality)

### Проблема: Service Bloat (Раздувание сервисов)
Класс `ProductService` берет на себя слишком много ответственности: создание, редактирование, работа с медиа, отзывы, поиск, фильтрация.
* **Риск:** Нарушение SRP (Single Responsibility Principle). Класс становится трудно поддерживать и тестировать. Любое изменение в логике продуктов требует правки этого гигантского файла.

### Решение: Vertical Slice Architecture (Pattern Use Case)
Вместо группировки по сущностям (`ProductService`), группируйте логику по **Действиям** (Use Cases), без использования лишних библиотек-посредников.

**Направление реализации:**
1.  Создайте папку `Features/Products` или `UseCases/Products`.
2.  Для каждой операции создайте отдельный класс-обработчик (Handler):
    * `CreateProductHandler` (содержит логику добавления)
    * `AddReviewHandler` (содержит логику отзывов)
    * `GetProductDetailsHandler` (содержит логику чтения)
3.  Внедряйте эти конкретные хендлеры в API Endpoint'ы.
    * *Пример:* Вместо `IProductService` в эндпоинт `POST /products` внедрите `CreateProductHandler`.
4.  Это изолирует логику каждой операции и упростит написание тестов.

---

## 5. Качество и Тестирование (Medium Criticality)

### Проблема: Недостаточное покрытие тестами
В проекте мало тестов, особенно интеграционных.
* **Риск:** Рефакторинг (который предложен выше) становится опасным, так как нет гарантии, что старый функционал не сломается.

### Решение: Интеграционное тестирование с Testcontainers

**Направление реализации:**
1.  Используйте библиотеку **Testcontainers for .NET** (бесплатно). Она позволяет поднимать настоящий PostgreSQL в Docker-контейнере на время тестов.
2.  Напишите тесты, которые используют `WebApplicationFactory` для вызова ваших API in-memory, но пишут в реальную (контейнерную) БД.
3.  Это даст максимальную уверенность в том, что вся цепочка (API -> Handler -> EF Core -> DB) работает корректно.

---

## 6. Прочие технические долги (Low Criticality)

### Проблема: Магические строки и Идемпотентность
1.  Имена политик авторизации (`"Seller"`, `"Admin"`) разбросаны строками по коду.
2.  В `OrderService` при оплате нет защиты от дубликатов (идемпотентности). Если фронтенд отправит запрос дважды, деньги спишутся дважды.

### Решение:
1.  **Константы:** Вынесите все строки политик в статический класс `AuthPolicies` или `Roles`.
2.  **Idempotency Key:**
    * Принимайте в заголовке запроса на создание заказа уникальный `Idempotency-Key` (генерируется на клиенте).
    * Перед обработкой проверяйте в БД (или Redis), не обрабатывался ли уже запрос с таким ключом.
    * Это стандартная практика для платежных систем (как Stripe).

---

## Сводный план действий (Roadmap)

1.  **Шаг 1 (Quick Win):** Рефакторинг "Псевдо-RPC". Замените `EventBus.PublishWithResult` на прямые вызовы интерфейсов сервисов между модулями для операций чтения (`Get...`).
2.  **Шаг 2 (Reliability):** Внедрение **MassTransit** + **Outbox**. Это решит проблему надежности событий.
3.  **Шаг 3 (Structure):** Постепенное распиливание `ProductService` на отдельные классы-хендлеры (Use Cases) для новых фич или при изменении старых.
4.  **Шаг 4 (Quality):** Написание интеграционных тестов на базе `Testcontainers` для критических путей (Оформление заказа, Регистрация).