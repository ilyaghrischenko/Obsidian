## **Что это**


SelectMany — это метод LINQ, который выполняет **проекцию последовательности последовательностей в одну плоскую последовательность**. По сути, он «расплющивает» коллекции коллекций.
  

Если Select вернёт коллекцию коллекций, то SelectMany объединит все вложенные коллекции в одну.

---

## **Зачем нужно**

- Чтобы работать с вложенными коллекциями без двойных циклов.
    
- Чтобы упростить запросы, где требуется агрегировать данные из списков внутри списков.
    
- Чтобы вернуть единую коллекцию элементов вместо «коллекции коллекций».
    

---

## **Разница с Select**


### **Select**

  
Возвращает коллекцию коллекций (каждый элемент проецируется в последовательность).

``` csharp
var users = new[]
{
    new { Name = "Alice", Phones = new[] {"111", "222"}},
    new { Name = "Bob", Phones = new[] {"333"}}
};

var phonesSelect = users.Select(u => u.Phones);
// Результат: IEnumerable<string[]> → [["111","222"], ["333"]]
```

### **SelectMany**


«Расплющивает» результат, возвращая одну последовательность.

``` csharp
var phonesSelectMany = users.SelectMany(u => u.Phones);
// Результат: IEnumerable<string> → ["111", "222", "333"]
```

---

## **Примеры использования**

  

### **1. Работа с вложенными коллекциями**

``` csharp
var customers = new[]
{
    new { Id = 1, Orders = new[] { "Book", "Pen" }},
    new { Id = 2, Orders = new[] { "Laptop" }}
};

var allOrders = customers.SelectMany(c => c.Orders);
// → ["Book", "Pen", "Laptop"]
```

### **2. Комбинация с проекцией**

  

Можно дополнительно формировать новые объекты.

``` csharp
var result = customers.SelectMany(
    c => c.Orders,
    (c, order) => new { CustomerId = c.Id, Order = order }
);

// → [{1, "Book"}, {1, "Pen"}, {2, "Laptop"}]
```

### **3. Поиск по вложенным коллекциям**

``` csharp
var found = customers
    .SelectMany(c => c.Orders)
    .Where(order => order.Contains("Book"));

// → ["Book"]
```

---

## **Когда использовать SelectMany**

  

Использовать SelectMany, когда:

- Нужно объединить все вложенные коллекции в одну.
    
- Нужно избавиться от «двойных циклов» (foreach внутри foreach).
    
- Нужно построить запрос с плоским результатом.
    

  

Использовать Select, когда:

- Нужно сохранить иерархию (получить список списков).
    

---

## **Оптимизации**

- SelectMany уменьшает уровень вложенности и упрощает работу с данными, что делает код **понятнее и короче**.
    
- Убирает лишние циклы при обработке вложенных коллекций.
    
- Может использоваться вместе с Where, OrderBy, GroupBy и другими LINQ-операторами для оптимизации запросов.
    

---

## **Мини-правило**

- Если после Select получается IEnumerable<IEnumerable(T)>, то чаще всего нужен SelectMany.
    
- Если нужна иерархическая структура (списки внутри списка) — оставляй Select.