
Concurrent коллекции в `System.Collections.Concurrent` предназначены для безопасной работы с данными в многопоточной среде. Они решают проблему гонки потоков, исключая необходимость явной блокировки (`lock`).

---

## Проблема, которую решают Concurrent коллекции

При одновременном доступе нескольких потоков к стандартным коллекциям (`List<T>`, `Dictionary<K,V>`, `Queue<T>` и т. д.) могут возникать проблемы:

- **Гонка потоков** (race condition) — несколько потоков изменяют коллекцию одновременно.
- **Исключения** (`InvalidOperationException`) при изменении коллекции во время итерации.
- **Необходимость ручной синхронизации** (`lock`), что усложняет код и снижает производительность.

Concurrent коллекции устраняют эти проблемы, автоматически обеспечивая потокобезопасный доступ.

---

## Основные Concurrent коллекции

### 1. `ConcurrentDictionary<K, V>` (Потокобезопасный словарь)

Позволяет безопасно добавлять, обновлять и удалять элементы без блокировок.

**Пример:**

```csharp
using System.Collections.Concurrent;

var dict = new ConcurrentDictionary<int, string>();

dict.TryAdd(1, "Первый");
dict[2] = "Второй";

if (dict.TryGetValue(1, out var value))
{
    Console.WriteLine(value); // Выведет: Первый
}
```

---

### 2. `ConcurrentQueue<T>` (Потокобезопасная очередь)

Работает по принципу FIFO (первый вошел – первый вышел). Безопасна для одновременного добавления и извлечения элементов.

**Пример:**

```csharp
var queue = new ConcurrentQueue<int>();
queue.Enqueue(10);
queue.Enqueue(20);

if (queue.TryDequeue(out int result))
{
    Console.WriteLine(result); // 10
}
```

---

### 3. `ConcurrentStack<T>` (Потокобезопасный стек)

Работает по принципу LIFO (последний вошел – первый вышел). Безопасен для многопоточного использования.

**Пример:**

```csharp
var stack = new ConcurrentStack<string>();
stack.Push("A");
stack.Push("B");

if (stack.TryPop(out string item))
{
    Console.WriteLine(item); // B
}
```

---

### 4. `ConcurrentBag<T>` (Потокобезопасный мешок)

Коллекция без фиксированного порядка. Используется, когда порядок элементов не имеет значения.

**Пример:**

```csharp
var bag = new ConcurrentBag<int>();
bag.Add(1);
bag.Add(2);

if (bag.TryTake(out int num))
{
    Console.WriteLine(num); // Может быть 1 или 2
}
```

---

### 5. `BlockingCollection<T>` (Коллекция с ограничением)

Обертка над другими `Concurrent` коллекциями, позволяющая ограничивать количество элементов и блокировать потоки при их добавлении или извлечении.

**Пример:**

```csharp
var blockingCollection = new BlockingCollection<int>(new ConcurrentQueue<int>(), 5);
blockingCollection.Add(42);
int value = blockingCollection.Take();
Console.WriteLine(value); // 42
```

---

## Когда использовать Concurrent коллекции?

- Когда несколько потоков **читают и изменяют** коллекцию одновременно.
- Когда нужна **высокая производительность** без явного `lock`.
- Когда стандартные коллекции (`List<T>`, `Dictionary<K,V>`, `Queue<T>`) вызывают **исключения** в многопоточной среде.
- В **параллельных алгоритмах**, очередях задач, кешах и многопоточных обработчиках событий.

---

## Заключение

Concurrent коллекции в C# – мощный инструмент для многопоточного программирования. Они помогают избежать гонки потоков и исключений, упрощая код и повышая производительность. Используйте их вместо обычных коллекций, если ваш код работает в многопоточной среде!