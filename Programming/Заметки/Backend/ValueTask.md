## **Что это такое**

  

ValueTask — это **структурный возвращаемый тип** для асинхронных методов, альтернатива Task. Он позволяет:

- Избегать аллокации Task-объекта, если результат уже доступен синхронно.
    
- Работать эффективнее в сценариях, где метод часто завершает работу сразу.
    

  

Есть два варианта:

- ValueTask — для методов без возвращаемого значения.
    
- ValueTask(T) — для методов с возвращаемым значением.
    

---

## **Зачем нужно**

- Task всегда создаёт объект → лишние аллокации при частых вызовах быстрых методов.
    
- ValueTask позволяет **возвращать результат без создания нового объекта**.
    
- Особенно полезно в высоконагруженных сценариях, где важна минимизация GC.
    

---

## **Основные примеры**

  

### **1. Возврат уже готового результата**

``` csharp
public ValueTask<int> GetNumberAsync(bool cached)
{
    if (cached)
        return new ValueTask<int>(42); // без аллокации Task

    return new ValueTask<int>(SlowOperationAsync()); // оборачиваем Task
}

private async Task<int> SlowOperationAsync()
{
    await Task.Delay(1000);
    return 42;
}
```

### **2. Использование** 

### **async ValueTask**

``` csharp
public async ValueTask<string> GetDataAsync(bool fast)
{
    if (fast)
        return "cached data"; // сразу возвращаем

    await Task.Delay(500);
    return "loaded from db";
}
```

Здесь async-метод сам решает:

- вернуть готовое значение (без Task-аллокации),
    
- или асинхронно дождаться.
    

  

### **3. Await** 

### **ValueTask**

``` csharp
var data = await GetDataAsync(true);
Console.WriteLine(data);
```

### **4. Использование** 

### **.AsTask()**

###  **при необходимости**

``` csharp
ValueTask<int> vt = GetNumberAsync(false);
Task<int> t = vt.AsTask();
int result = await t;
```

Используется редко, когда нужен именно Task API (например, Task.WhenAll).

---

## **Как правильно использовать**

- ✅ Используй ValueTask **если метод часто завершается синхронно** (например, кэш, пул объектов).
    
- ✅ Для долгих операций без мгновенного результата → **лучше Task**.
    
- ❌ Не используйте ValueTask в публичных API без необходимости: он сложнее, чем Task.
    
- ❌ Не await-ить один и тот же ValueTask дважды (он не гарантирует повторного await).
    

---

## **Выбор:** 

## **async ValueTask**

##  **vs** 

## **ValueTask**

- **ValueTask/ValueTask(T) (без async)** — минимальный оверхед: нет state machine. Идеально, когда **частые синхронные завершения (≈≥80–90%)** и нужен быстрый «горячий» путь. Пример: кэш-хит, пул/канал TryRead.
    
- **async ValueTask/ValueTask(T)** — генерируется state machine. Если метод **реально ждёт (await)**, будут расходы, сравнимые с async Task (возможны heap-аллокации на продолжения). Если метод **возвращает сразу**, heap-аллокаций обычно нет, но есть небольшой фиксированный оверхед на state machine. Удобно, когда **иногда** нужна асинхронность, но **синхронный путь случается заметно часто**.
    
- **Если асинхронный путь доминирует (≈>50–60%)** или метод долгий — **используй Task/Task(T)**: проще потребление и производительность не хуже, а иногда лучше (нет обёртки ValueTask вокруг Task).
    

  

### **Мини-пример выбора**

``` csharp
// Часто синхронно → non-async ValueTask
public ValueTask<Item?> TryGetAsync(Key k)
{
    if (_cache.TryGetValue(k, out var v))
        return new ValueTask<Item?>(v); // мгновенно, без state machine
    return new ValueTask<Item?>(LoadAsync(k)); // редкий медленный путь
}

// Иногда синхронно, иногда нет → async ValueTask
public async ValueTask<Item> GetAsync(Key k)
{
    if (_cache.TryGetValue(k, out var v))
        return v; // быстрый путь
    return await LoadAsync(k); // медленный путь
}

// Почти всегда медленно → Task
public Task<Item> GetFromDbAsync(Key k) => _repo.LoadAsync(k);
```

---

## **Когда переходить с Task на ValueTask**

  

**Правило 80/20 (ориентир):** переводи на ValueTask, если метод:

1. **Вызывается очень часто** (горячий путь),
    
2. **Значимая доля вызовов завершается синхронно** (кэш-хиты, готовые результаты),
    
3. **Из-за аллокаций Task заметен GC-pressure** в профайлере.
    

  

**Как понять на практике:**

- Замерь (BenchmarkDotNet, диагностические счётчики, профайлер):
    
    - число аллокаций/байт на вызов,
        
    - % синхронных завершений,
        
    - паузы GC / Throughput.
        
    
- Если **синхронных завершений много** и **аллокации ощутимы** → ValueTask даст выигрыш.
    
- Если **почти всегда есть await** или метод не в горячем пути → **оставь Task**.
    

  

**Памятка по применению:**

- Синхронный быстрый путь доминирует → **ValueTask без async** (самый дешёвый вариант).
    
- Быстрый путь есть, но логика требует await в части случаев → **async ValueTask**.
    
- Долгие/IO-операции, редкие синхронные завершения → **Task**.
    

  

**Замечания по потреблению:**

- ValueTask **нельзя await-ить несколько раз**, если он опирается на IValueTaskSource (безопасно — один раз). Если нужна повторная сигнализация/композиция (WhenAll, WhenAny) — используйте vt.AsTask() или изначально возвращайте Task.
    
- Для мгновенно завершённого ValueTask без результата возвращай default; для ValueTask(T) — new ValueTask(T)(value).
    

---

## **Главное**

- ValueTask экономит память и аллокации.
    
- async ValueTask позволяет вернуть как готовый результат, так и ожидание.
    
- Хорош для **низкоуровневых библиотек** и **высоконагруженного кода**.
    
- В большинстве случаев → достаточно обычного Task. Используй ValueTask осознанно.