## **Введение**


Модульный монолит — это архитектурный стиль, при котором приложение состоит из независимых **модулей** (feature-модулей), каждый из которых инкапсулирует свою бизнес-логику, но при этом все модули разворачиваются и работают в рамках одного приложения (монолита).

  

**Ключевые особенности:**

- Чёткая граница между модулями.
    
- Минимизация связей между модулями.
    
- Возможность независимой разработки и тестирования модулей.
    
- В перспективе модуль можно вынести в отдельный микросервис.
    

---

## **Структура модулей**

  

Каждый модуль реализуется с использованием **[[Clean Architecture]]**:

```
ModuleName/
 ├─ ModuleName.Api          // HTTP API (эндпоинты)
 ├─ ModuleName.Application  // Application layer — use cases, CQRS, обработчики команд/запросов
 ├─ ModuleName.Domain       // Бизнес-логика, агрегаты, сущности, Value Objects, доменные события
 ├─ ModuleName.Infrastructure // Доступ к БД, реализации интерфейсов, интеграции
 ├─ ModuleName.DTO          // DTO-объекты для передачи данных
 ├─ ModuleName.IntegrationEvents // Контракты событий для обмена между модулями
```

**Особенности:**

- **IntegrationEvents** — единственный слой, на который могут ссылаться другие модули. Используется для подписки/публикации событий.
    
- **Domain** не зависит ни от одного другого слоя.
    
- **Application** зависит только от **Domain** и **IntegrationEvents** (при необходимости).
    
- **Infrastructure** зависит от **Application** и **Domain**, но не наоборот.
    

---

## **Взаимодействие между модулями**

  

### **Прямые вызовы (по возможности избегать)**

  

Если модуль A вызывает код модуля B напрямую — это создаёт жёсткую связанность.

  

### **Асинхронное взаимодействие через IntegrationEvents**

1. Модуль **User** публикует событие UserCreatedEvent в своём IntegrationEvents.
    
2. Модуль **Orders** подписывается на это событие, реализуя обработчик.
    
3. Связь осуществляется только через контракты событий, без прямого доступа к внутренней логике.
    

  

**Пример события:**

```
public record UserCreatedEvent(Guid UserId, string Email);
```

---

## **Общий модуль (Shared / SharedKernel)**

  

### **Назначение**

  

Shared или SharedKernel — это модуль с общими компонентами, используемыми несколькими модулями.

  

Структура также следует **Чистой архитектуре**:

```
Shared/
 ├─ Shared.Application
 ├─ Shared.Domain
 ├─ Shared.Infrastructure
```

### **Что хранить в Shared:**

- Общие Value Objects (например, Money, Email)
    
- Базовые интерфейсы (IAggregateRoot, IRepository, IDomainEvent)
    
- Общие исключения
    
- Базовые классы для доменных событий, обработчиков
    

  

**Важно:**

- Shared не должен содержать бизнес-логику конкретного модуля.
    
- Остальные модули могут ссылаться на Shared.
    

---

## **Зависимости между проектами**

  

### **Правила ссылок:**

- **Domain** → не ссылается ни на что.
    
- **Application** → ссылается на Domain и при необходимости на IntegrationEvents.
    
- **Infrastructure** → ссылается на Application, Domain, Shared.
    
- **Api** → ссылается на Application и IntegrationEvents.
    
- **IntegrationEvents** → может ссылаться на Shared (для общих типов), но не на Domain.
    

  

**Схема:**

```
[Api] → [Application] → [Domain]
  ↓
[IntegrationEvents]
```

---

## **Преимущества подхода**

- Чёткое разделение ответственности.
    
- Лёгкость масштабирования (вынесение модуля в отдельный сервис).
    
- Контролируемое взаимодействие через IntegrationEvents.
    
- Лучшая тестируемость.
    
- Возможность независимой эволюции модулей.
    

---

## **Итог**

  

Модульный монолит с чистой архитектурой и выделенным IntegrationEvents слоем обеспечивает изоляцию модулей, упрощает сопровождение и открывает путь для постепенного перехода к микросервисам. Общий модуль Shared используется для хранения переиспользуемых компонентов и также следует принципам чистой архитектуры.